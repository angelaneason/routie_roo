import { describe, expect, it, beforeEach, vi } from "vitest";
import { sql } from "drizzle-orm";

/**
 * Tests for automatic route cleanup when contact schedules are deleted
 * 
 * Business logic:
 * - When a contact's schedule is removed (scheduledDays becomes empty)
 * - Find all auto-generated routes containing that contact
 * - If route is incomplete (no completedAt timestamp)
 * - And route has no remaining waypoints after removing the contact
 * - Delete the entire route (it's just an empty shell)
 * - Keep completed routes for historical records
 */

describe("Route Cleanup on Schedule Deletion", () => {
  describe("Route deletion criteria", () => {
    it("should delete route when auto-generated, incomplete, and empty", () => {
      const route = {
        id: 1,
        isAutoGenerated: true,
        completedAt: null,
      };
      const remainingWaypoints = []; // No waypoints left after contact removal
      
      const shouldDelete = route.isAutoGenerated && !route.completedAt && remainingWaypoints.length === 0;
      expect(shouldDelete).toBe(true);
    });

    it("should keep route when completed (has completedAt)", () => {
      const route = {
        id: 1,
        isAutoGenerated: true,
        completedAt: new Date(),
      };
      const remainingWaypoints = [];
      
      const shouldDelete = route.isAutoGenerated && !route.completedAt && remainingWaypoints.length === 0;
      expect(shouldDelete).toBe(false);
    });

    it("should keep route when manually created (not auto-generated)", () => {
      const route = {
        id: 1,
        isAutoGenerated: false,
        completedAt: null,
      };
      const remainingWaypoints = [];
      
      const shouldDelete = route.isAutoGenerated && !route.completedAt && remainingWaypoints.length === 0;
      expect(shouldDelete).toBe(false);
    });

    it("should keep route when other waypoints remain", () => {
      const route = {
        id: 1,
        isAutoGenerated: true,
        completedAt: null,
      };
      const remainingWaypoints = [
        { id: 2, position: 1, contactId: 456 }, // Another contact still on route
      ];
      
      const shouldDelete = route.isAutoGenerated && !route.completedAt && remainingWaypoints.length === 0;
      expect(shouldDelete).toBe(false);
    });
  });

  describe("Waypoint counting logic", () => {
    it("should exclude starting point (position 0) when counting waypoints", () => {
      const allWaypoints = [
        { id: 1, position: 0, contactId: null }, // Starting point
        { id: 2, position: 1, contactId: 123 }, // The contact being removed
      ];
      
      // After removing contact 123, only starting point remains
      const remainingWaypoints = allWaypoints.filter(w => w.position > 0 && w.contactId !== 123);
      
      expect(remainingWaypoints.length).toBe(0);
    });

    it("should count actual stops (position > 0)", () => {
      const allWaypoints = [
        { id: 1, position: 0, contactId: null }, // Starting point
        { id: 2, position: 1, contactId: 123 }, // The contact being removed
        { id: 3, position: 2, contactId: 456 }, // Another contact
        { id: 4, position: 3, contactId: 789 }, // Another contact
      ];
      
      // After removing contact 123, two stops remain
      const remainingWaypoints = allWaypoints.filter(w => w.position > 0 && w.contactId !== 123);
      
      expect(remainingWaypoints.length).toBe(2);
    });
  });

  describe("SQL query construction", () => {
    it("should use correct SQL for position > 0 check", () => {
      // Verify the SQL template literal syntax is correct
      const mockRouteWaypoints = { position: "position" };
      const positionCheck = sql`${mockRouteWaypoints.position} > 0`;
      
      expect(positionCheck).toBeDefined();
    });
  });

  describe("Cleanup workflow", () => {
    it("should follow correct deletion order: waypoints first, then route", () => {
      const deletionOrder: string[] = [];
      
      // Simulate the deletion workflow
      const mockDeleteWaypoints = () => deletionOrder.push("delete_waypoints");
      const mockDeleteRoute = () => deletionOrder.push("delete_route");
      
      // Execute cleanup
      mockDeleteWaypoints(); // Delete all waypoints first
      mockDeleteRoute();     // Then delete the route
      
      expect(deletionOrder).toEqual(["delete_waypoints", "delete_route"]);
    });
  });

  describe("Edge cases", () => {
    it("should handle route with only starting point gracefully", () => {
      const route = {
        id: 1,
        isAutoGenerated: true,
        completedAt: null,
      };
      const allWaypoints = [
        { id: 1, position: 0, contactId: null }, // Only starting point
      ];
      
      const remainingWaypoints = allWaypoints.filter(w => w.position > 0);
      const shouldDelete = route.isAutoGenerated && !route.completedAt && remainingWaypoints.length === 0;
      
      expect(shouldDelete).toBe(true);
    });

    it("should handle multiple contacts being removed from same route", () => {
      const route = {
        id: 1,
        isAutoGenerated: true,
        completedAt: null,
      };
      const contactsToRemove = [123, 456];
      const allWaypoints = [
        { id: 1, position: 0, contactId: null },
        { id: 2, position: 1, contactId: 123 },
        { id: 3, position: 2, contactId: 456 },
        { id: 4, position: 3, contactId: 789 }, // This one stays
      ];
      
      const remainingWaypoints = allWaypoints.filter(
        w => w.position > 0 && !contactsToRemove.includes(w.contactId!)
      );
      
      expect(remainingWaypoints.length).toBe(1);
      
      const shouldDelete = route.isAutoGenerated && !route.completedAt && remainingWaypoints.length === 0;
      expect(shouldDelete).toBe(false); // Should keep because one contact remains
    });
  });

  describe("Historical record preservation", () => {
    it("should preserve completed routes regardless of waypoint count", () => {
      const completedRoute = {
        id: 1,
        isAutoGenerated: true,
        completedAt: new Date("2025-12-01"),
      };
      const remainingWaypoints: any[] = []; // Empty after contact removal
      
      const shouldDelete = completedRoute.isAutoGenerated && !completedRoute.completedAt && remainingWaypoints.length === 0;
      
      expect(shouldDelete).toBe(false); // Keep for historical records
    });

    it("should preserve manually created routes even when empty", () => {
      const manualRoute = {
        id: 1,
        isAutoGenerated: false,
        completedAt: null,
      };
      const remainingWaypoints: any[] = [];
      
      const shouldDelete = manualRoute.isAutoGenerated && !manualRoute.completedAt && remainingWaypoints.length === 0;
      
      expect(shouldDelete).toBe(false); // Keep user-created routes
    });
  });
});
